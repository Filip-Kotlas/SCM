#pragma once
#include "geom.h"
#include "getmatrix.h"
#include "crsmatrix_gpu.h"
#include <vector>

/**
 * Solves linear system of equations  K @p u = @p f  via the Jacobi iteration on GPU.
 * We use a distributed symmetric  CSR matrix @p SK and initial guess of the
 * solution is set to 0.
 * @param[in] SK	CSR matrix
 * @param[in] f		distributed local vector storing the right hand side
 * @param[out] u	accumulated local vector storing the solution.
*/
void JacobiSolve_GPU(CRS_Matrix_GPU const &d_SK, Vec const &f, Vec &u);


/**
 * Solves linear system of equations  K @p u = @p f  via the Jacobi iteration.
 * We use a distributed symmetric  CSR matrix @p SK and initial guess of the
 * solution is set to 0.
 *
 * In each smoothing step: @f$ \widehat{u} := u + \omega D^{-1}\left({f-K*u}\right) @f$
 *
 * @param[in]  SK	CSR matrix
 * @param[in]  f	distributed local vector storing the right hand side
 * @param[out] u	accumulated local vector storing the solution.
 * @param[in,out] r	auxiliary local vector.
 * @param[in] nsmooth	number of smoothing steps.
 * @param[in] omega	relaxation parameter.
 * @param[in] zero	initial solution @p u is assumed to be zero.
*/
void JacobiSmoother(Matrix const &SK, std::vector<double> const &f, std::vector<double> &u,
                    std::vector<double> & r, int nsmooth=1, double omega=1.0, bool zero=false);

/**
 * @brief Simple diagonale preconditioning.
 *
 * The residuum @p r scaled by the inverse diagonal of matr√≠x @p SK results in the correction @p w.
 *
 * @f$ w :=  \omega D^{-1}*r @f$
 *
 * @param[in]  SK	matrix
 * @param[in]  r	distributed local vector storing the residuum
 * @param[out] w	accumulated local vector storing the correction.
 * @param[in] omega	relaxation parameter.
*/
void DiagPrecond(Matrix const &SK, std::vector<double> const &r, std::vector<double> &w,
                 double omega=1.0);



/**
 * @brief The Multigrid hierarchy including meshes, vectors and matrices, prolongations is stored.
*/
class Multigrid
{
    public:
       /**
        * Generates the mesh hierachy with @p nlevel meshes starting from coarse mesh @p cmesg .
        *
        * The refined meshes are generated by edge bisection.
        * All memory is allocated but stiffness matrices are yet not calculated
	    *
        * @param[in] cmesh	  initial coarse mesh
        * @param[in] nlevel  number of meshes in hierarchy, including the initial coarse mesh
        *
		*/
       Multigrid(Mesh const &cmesh, int nlevel, std::vector<FEM_Matrix> matrices_for_setup,
                std::vector<std::vector<double>> u, std::vector<std::vector<double>> f, std::vector<std::vector<double>> d, std::vector<std::vector<double>> w );

       Multigrid(Multigrid const&)            = delete;
       Multigrid& operator=(Multigrid const&) = delete;

       ~Multigrid();

       /**
		 * @return  Number of meshes in hierarchy.
		 */
       [[nodiscard]]int Nlevels() const
       {return static_cast<int>(_meshes.size()); }

       /**
		 * @return  Number of Unknowns.
		 */
       [[nodiscard]] int Ndofs() const
       {return _meshes[Nlevels()-1].Nnodes(); }

       /**
		 * @return  Meshes number @p lev .
		*/
       [[nodiscard]] Mesh const& GetMesh(int lev) const
       { return _meshes[lev]; }

       /**
		 * @return  Solution vector at level @p lev .
		 */
       [[nodiscard]] Vec const&  GetSolution(int lev) const
       { return _u.at(lev); }

       /**
		 * Calculates PDE matrices for all levels.
		 */
       void DefineOperators( std::vector<FEM_Matrix> matrices_for_setup, std::vector<std::vector<double>> u, std::vector<std::vector<double>> f );

       /**
        * Calculates PDE matrix for level @p lev.
        *
        * @param[in] lev  level in hierachy
		*/
       void DefineOperator(int lev, FEM_Matrix mat, std::vector<double> u, std::vector<double> f);

        /**
        * Transfers data from temporary objects to the class atributes.
		*/
       void finish_setup(   std::vector<FEM_Matrix> matrices_for_setup,
                            std::vector<std::vector<double>> u,
                            std::vector<std::vector<double>> f,
                            std::vector<std::vector<double>> d, 
                            std::vector<std::vector<double>> w );

       /**
        * Solves the system of equations at level @p lev via Jacobi iterations
        *
        * @param[in] lev  level in hierachy
		*/
       void JacobiSolve(int lev);

      /**
       * Peforms one multigrid step at level @p lev .
       *
       * @param[in] lev         level in hierachy
       * @param[in] pre_smooth  number of pre/post-smoothing sweeps
       * @param[in] bzero       start with zero-vector as solution
       * @param[in] nu          defines the multigrid cycle (1/2 = V/W)
       */
       void MG_Step(int lev, int pre_smooth=1, bool bzero=false, int nu=1);

      /**
       * Solves the system of equations at finest level via multigrid
       *
       * @param[in] pre_smooth  number of pre/post-smoothing sweeps
       * @param[in] eps         stopping criteria (relative error)
       * @param[in] nu          defines the multigrid cycle (1/2 = V/W)
	   */
       void MG_Solve(int pre_smooth=1, double eps=1e-6, int nu=1);

    [[maybe_unused]] bool checkInterpolation(int lev);

    [[maybe_unused]] bool checkRestriction(int lev);


    private:
       gMesh_Hierarchy _meshes;                 //!< mesh hierarchy from coarse (level 0) to fine.
       std::vector<CRS_Matrix_GPU>           _vSK;  //!< Sparse matrix on each level.
       std::vector<Vec>   _u;   //!< Solution vector on each level.
       std::vector<Vec>   _f;   //!< Right hand side vector on each level.
       std::vector<Vec>   _d;   //!< Defect vector on each level.
       std::vector<Vec>   _w;   //!< Correction vector on each level.
       std::vector<CRS_Matrix_GPU> _vPc2f;  //!< Interpolation to level from next coarser level.
};

#pragma once
#include "geom.h"
#include "getmatrix.h"
#include <vector>
#include "crsmatrix_gpu.h"
#include "vdop_gpu.h"
#include "cusparse.h"


/**
 * Solves linear system of equations  K @p u = @p f  via the Jacobi iteration.
 * We use a distributed symmetric  CSR matrix @p SK and initial guess of the
 * solution is set to 0.
 * @param[in] SK	CSR matrix
 * @param[in] f		distributed local vector storing the right hand side
 * @param[out] u	accumulated local vector storing the solution.
*/
void JacobiSolve(CRS_Matrix const &SK, std::vector<double> const &f, std::vector<double> &u);


/**
 * Solves linear system of equations  K @p u = @p f  via the Jacobi iteration.
 * We use a distributed symmetric  CSR matrix @p SK and initial guess of the
 * solution is set to 0.
 *
 * In each smoothing step: @f$ \widehat{u} := u + \omega D^{-1}\left({f-K*u}\right) @f$
 *
 * @param[in]  SK	CSR matrix
 * @param[in]  f	distributed local vector storing the right hand side
 * @param[out] u	accumulated local vector storing the solution.
 * @param[in,out] r	auxiliary local vector.
 * @param[in] nsmooth	number of smoothing steps.
 * @param[in] omega	relaxation parameter.
 * @param[in] zero	initial solution @p u is assumed to be zero.
*/
void JacobiSmoother(Matrix const &SK, std::vector<double> const &f, std::vector<double> &u,
                    std::vector<double> & r, int nsmooth=1, double omega=1.0, bool zero=false);

/**
 * @brief Simple diagonale preconditioning.
 *
 * The residuum @p r scaled by the inverse diagonal of matríx @p SK results in the correction @p w.
 *
 * @f$ w :=  \omega D^{-1}*r @f$
 *
 * @param[in]  SK	matrix
 * @param[in]  r	distributed local vector storing the residuum
 * @param[out] w	accumulated local vector storing the correction.
 * @param[in] omega	relaxation parameter.
*/
void DiagPrecond(Matrix const &SK, std::vector<double> const &r, std::vector<double> &w,
                 double omega=1.0);

/**
 * @brief The Multigrid hierarchy including meshes, vectors and matrices, prolongations is stored.
*/
class Multigrid
{
    public:
       /**
        * Generates the mesh hierachy with @p nlevel meshes starting from coarse mesh @p cmesg .
        *
        * The refined meshes are generated by edge bisection.
        * All memory is allocated but stiffness matrices are yet not calculated
	    *
        * @param[in] cmesh	  initial coarse mesh
        * @param[in] nlevel  number of meshes in hierarchy, including the initial coarse mesh
        *
		*/
       Multigrid(Mesh const& cmesh, int nlevel);

       Multigrid(Multigrid const&)            = delete;
       Multigrid& operator=(Multigrid const&) = delete;

       ~Multigrid();

       /**
		 * @return  Number of meshes in hierarchy.
		 */
       [[nodiscard]]int Nlevels() const
       {return static_cast<int>(_meshes.size()); }

       /**
		 * @return  Number of Unknowns.
		 */
       [[nodiscard]] int Ndofs() const
       {return _meshes[Nlevels()-1].Nnodes(); }

       /**
		 * @return  Meshes number @p lev .
		*/
       [[nodiscard]] Mesh const& GetMesh(int lev) const
       { return _meshes[lev]; }

       /**
		 * @return  Solution vector at level @p lev .
		 */
       [[nodiscard]] std::vector<double> const&  GetSolution(int lev) const
       { return _u.at(lev); }

       /**
		 * Calculates PDE matrices for all levels.
		 */
       void DefineOperators();

       /**
        * Calculates PDE matrix for level @p lev.
        *
        * @param[in] lev  level in hierachy
		*/
       void DefineOperator(int lev);

       /**
        * Solves the system of equations at level @p lev via Jacobi iterations
        *
        * @param[in] lev  level in hierachy
		*/
       void JacobiSolve(int lev);

      /**
       * Peforms one multigrid step at level @p lev .
       *
       * @param[in] lev         level in hierachy
       * @param[in] pre_smooth  number of pre/post-smoothing sweeps
       * @param[in] bzero       start with zero-vector as solution
       * @param[in] nu          defines the multigrid cycle (1/2 = V/W)
       */
       void MG_Step(int lev, int pre_smooth=1, bool bzero=false, int nu=1);

      /**
       * Solves the system of equations at finest level via multigrid
       *
       * @param[in] pre_smooth  number of pre/post-smoothing sweeps
       * @param[in] eps         stopping criteria (relative error)
       * @param[in] nu          defines the multigrid cycle (1/2 = V/W)
	   */
       void MG_Solve(int pre_smooth=1, double eps=1e-6, int nu=1);

    [[maybe_unused]] bool checkInterpolation(int lev);

    [[maybe_unused]] bool checkRestriction(int lev);

    friend class Multigrid_GPU;

    private:
       gMesh_Hierarchy _meshes;                 //!< mesh hierarchy from coarse (level 0) to fine.
       std::vector<FEM_Matrix>           _vSK;  //!< Sparse matrix on each level.
       std::vector<std::vector<double>>   _u;   //!< Solution vector on each level.
       std::vector<std::vector<double>>   _f;   //!< Right hand side vector on each level.
       std::vector<std::vector<double>>   _d;   //!< Defect vector on each level.
       std::vector<std::vector<double>>   _w;   //!< Correction vector on each level.
       std::vector<BisectIntDirichlet> _vPc2f;  //!< Interpolation to level from next coarser level.
};

/**
 * Solves linear system of equations  K @p u = @p f  via the Jacobi iteration.
 * We use a distributed symmetric  CSR matrix @p SK and initial guess of the
 * solution is set to 0.
 * @param[in] SK	CSR matrix
 * @param[in] f		distributed local vector storing the right hand side
 * @param[out] u	accumulated local vector storing the solution.
*/
void JacobiSolve_GPU(CRS_Matrix_GPU const &SK, Vec const &f, Vec &u);

/**
 * Solves linear system of equations  K @p u = @p f  via the Jacobi iteration.
 * We use a distributed symmetric  CSR matrix @p SK and initial guess of the
 * solution is set to 0.
 *
 * In each smoothing step: @f$ \widehat{u} := u + \omega D^{-1}\left({f-K*u}\right) @f$
 *
 * @param[in]  SK	CSR matrix
 * @param[in]  f	distributed local vector storing the right hand side
 * @param[out] u	accumulated local vector storing the solution.
 * @param[in,out] r	auxiliary local vector.
 * @param[in] nsmooth	number of smoothing steps.
 * @param[in] omega	relaxation parameter.
 * @param[in] zero	initial solution @p u is assumed to be zero.
*/
void JacobiSmoother_GPU(CRS_Matrix_GPU const &SK, Vec const &f, Vec &u,
                    Vec &r, int nsmooth, double const omega, bool zero);

/**
 * @brief Simple diagonale preconditioning.
 *
 * The residuum @p r scaled by the inverse diagonal of matríx @p SK results in the correction @p w.
 *
 * @f$ w :=  \omega D^{-1}*r @f$
 *
 * @param[in]  SK	matrix
 * @param[in]  r	distributed local vector storing the residuum
 * @param[out] w	accumulated local vector storing the correction.
 * @param[in] omega	relaxation parameter.
*/
void DiagPrecond_GPU(CRS_Matrix_GPU const &SK, Vec const &r, Vec &w, double const omega = 1.0);


class Multigrid_GPU
{
    public:
        Multigrid_GPU( Multigrid const & source );

        Multigrid_GPU(Multigrid_GPU const&)            = delete;
        Multigrid_GPU& operator=(Multigrid_GPU const&) = delete;

        ~Multigrid_GPU();

        /**
		 * @return  Number of meshes in hierarchy.
		 */
        [[nodiscard]]int Nlevels() const
        {return nlev; }

        /**
		 * @return  Number of Unknowns.
		 */
        [[nodiscard]] int Ndofs() const
        {return ndofs; }

        /**
		 * @return  Solution vector at level @p lev .
		 */
        [[nodiscard]] Vec const&  GetSolution(int lev) const
        { return _u.at(lev); }

        /**
         * Solves the system of equations at level @p lev via Jacobi iterations
         *
         * @param[in] lev  level in hierachy
		 */
        void JacobiSolve(int lev);

        /**
         * Peforms one multigrid step at level @p lev .
         *
         * @param[in] lev         level in hierachy
         * @param[in] pre_smooth  number of pre/post-smoothing sweeps
         * @param[in] bzero       start with zero-vector as solution
         * @param[in] nu          defines the multigrid cycle (1/2 = V/W)
         */
        void MG_Step(int lev, int pre_smooth=1, bool bzero=false, int nu=1);

        /**
         * Solves the system of equations at finest level via multigrid
         *
         * @param[in] pre_smooth  number of pre/post-smoothing sweeps
         * @param[in] eps         stopping criteria (relative error)
         * @param[in] nu          defines the multigrid cycle (1/2 = V/W)
	     */
        void MG_Solve(int pre_smooth=1, double eps=1e-6, int nu=1);

        [[maybe_unused]] bool checkInterpolation(int const lev);

        [[maybe_unused]] bool checkRestriction(int const lev);

        [[nodiscard]] Mesh const& GetMesh(int lev) const
            { return _meshes[lev]; }

    private:
        int                             nlev;    //!< Number of levels
        int                             ndofs;  //!< Number of unknowns
        std::vector<CRS_Matrix_GPU>     _vSK;   //!< Sparse matrix on each level.
        std::vector<Vec>                _u;     //!< Solution vector on each level.
        std::vector<Vec>                _f;     //!< Right hand side vector on each level.
        std::vector<Vec>                _d;     //!< Defect vector on each level.
        std::vector<Vec>                _w;     //!< Correction vector on each level.
        std::vector<CRS_Matrix_GPU>     _vPc2f; //!< Interpolation to level from next coarser level.

       gMesh_Hierarchy _meshes;                 //!< mesh hierarchy from coarse (level 0) to fine.

};
